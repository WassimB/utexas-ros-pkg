#!/usr/bin/env python

import roslib; roslib.load_manifest('bwi_apps')
import rospy, actionlib

from bwi_msgs.msg import ObjectArray
from bwi_msgs.msg import MultiLevelMapPoint
from bwi_msgs.srv import NavigatePerson
from bwi_msgs.srv import MakeNavPlan
from bwi_msgs.srv import NavigatePersonResponse
from move_base_msgs.msg import MoveBaseAction
from move_base_msgs.msg import MoveBaseGoal
from geometry_msgs.msg import PoseStamped

class BWINavigator:
  def __init__(self):
    rospy.init_node('bwi_navigator')

    #get parameters
    try:
      self.robot_list = rospy.get_param('~robot_list')
    except:
      rospy.logfatal("Please provide robot list (~robot_list)")
      return

    self.robot_controller = dict()
    #robot controllers
    for level, robot in self.robot_list.iteritems():
      rospy.loginfo("Waiting for robot: %s " %(robot));
      self.robot_controller[robot] = actionlib.SimpleActionClient("/" + robot + "/move_base", MoveBaseAction)
      self.robot_controller[robot].wait_for_server()

    rospy.loginfo("Waiting for path provider");
    rospy.wait_for_service('/path_provider/make_plan')
    self.makeNavPlan = rospy.ServiceProxy('/path_provider/make_plan', MakeNavPlan)

    self.current_persons = dict()
    self.current_robots = dict()

    self.person_subscriber = rospy.Subscriber("/person_detections", ObjectArray, self.personCallback)
    self.person_subscriber = rospy.Subscriber("/robot_detections", ObjectArray, self.robotCallback)
    self.service_server = rospy.Service("/navigate", NavigatePerson, self.navigateCallback) 

    rospy.loginfo("Starting spin");
    rospy.spin()

  def personCallback(self, data):
    for person in data.objects:
      self.current_persons[person.id] = person

  def robotCallback(self, data):
    for robot in data.objects:
      self.current_robots[robot.id] = robot

  def getPoseFromObject(self, object):
    return self.getPoseFromPoint(object.point.point, object.point.header.frame_id)

  def getPoseFromPoint(self, point, frame):
    pose = PoseStamped()
    pose.header.frame_id = frame
    pose.header.stamp = rospy.Time.now()
    pose.pose.position = point
    #some better way to calculate orientation?
    pose.pose.orientation.x = 0
    pose.pose.orientation.y = 0
    pose.pose.orientation.z = 0
    pose.pose.orientation.w = 1
    return pose

  def navigateCallback(self, data):

    response = NavigatePersonResponse()

    person_id = data.person_id
    if not person_id in self.current_persons: #we don't know where this person is
      response.success = False
      return response
    person = self.current_persons[person_id]
    level1 = person.level
    level2 = data.goal.level_name
    frame_id1 = "/" + level1 + "/map"
    frame_id2 = "/" + level2 + "/map"
    robot_controller1 = self.robot_controller[self.robot_list[level1]]
    robot_controller2 = self.robot_controller[self.robot_list[level2]]

    #send robot1 to person
    goal1 = MoveBaseGoal()
    goal2 = MoveBaseGoal()
    goal1.target_pose = self.getPoseFromObject(person)
    robot_controller1.send_goal(goal1)
    robot_controller1.wait_for_result()

    # see if destination is on the same level or not
    if level2 == level1:
      goal1.target_pose = self.getPoseFromPoint(data.goal.point, frame_id1)
      robot_controller1.send_goal(goal1)
      robot_controller1.wait_for_result()
      response.success = True
      return response

    # otherwise find grand master navigation plan and move both robots into position
    start = MultiLevelMapPoint()
    start.frame_id = frame_id1
    start.level_name = level1
    start.point = person.point.point
    plan = self.makeNavPlan(start, data.goal)
    if not plan.plan_found:
      rospy.logerror("Unable to find grand master navigation plan. Boo!")
      response.success = False
      return response

    #otherwise move robots
    goal1.target_pose = self.getPoseFromPoint(plan.start_level_goal, frame_id1)
    robot_controller1.send_goal(goal1)
    goal2.target_pose = self.getPoseFromPoint(plan.goal_level_start, frame_id2)
    robot_controller2.send_goal(goal2)

    #wait for both robots to complete
    robot_controller1.wait_for_result()
    robot_controller2.wait_for_result()

    #finally, move robot2 to final goal
    #TODO (need to wait till person arrives)
    goal2.target_pose = self.getPoseFromPoint(data.goal.point, frame_id2)
    robot_controller2.send_goal(goal2)
    robot_controller2.wait_for_result()

    response.success = True
    return response

if __name__ == '__main__':
  BWINavigator()
