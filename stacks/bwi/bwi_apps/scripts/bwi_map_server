#!/usr/bin/env python

import roslib; roslib.load_manifest('bwi_apps')
import rospy

import yaml, os
from PIL import Image

from tf.transformations import quaternion_from_euler
from nav_msgs.srv import GetMap
from nav_msgs.srv import GetMapResponse
from nav_msgs.msg import OccupancyGrid
from nav_msgs.msg import MapMetaData

# from bwi_msgs.msg import MultiLevelMap

class MapServer:
  def __init__(self):
    rospy.init_node('listener', anonymous=True)

    #get parameters
    self.global_frame_id = rospy.get_param('~global_frame_id', 'map')
    try:
      self.map_list = rospy.get_param('~maps')
    except:
      rospy.logfatal("Please provide map list (~maps)")
      return

    self.map_response = dict()
    self.service_server = dict()
    self.metadata_publisher = dict()
    self.map_publisher = dict()

    for map_name, yaml_file in self.map_list.items():

      try:
        map_info = yaml.load(open(yaml_file, 'r'))
      except:
        rospy.logfatal("Unable to load yaml file for map: %s" %yaml_file)
        return

      resolution = map_info.get('resolution')
      origin = map_info.get('origin')
      negate = map_info.get('negate')
      occupied_thresh = map_info.get('occupied_thresh')
      free_thresh = map_info.get('free_thresh')

      image_file = map_info.get('image')
      if image_file[0] != '/': 
        yaml_file_dir = os.path.dirname(os.path.realpath(yaml_file))
        image_file = yaml_file_dir + '/' + image_file

      self.map_response[map_name] = self.loadMapFromFile(image_file, resolution,
          negate, occupied_thresh, free_thresh, origin)
      self.map_response[map_name].map.info.map_load_time = rospy.get_rostime()
      self.map_response[map_name].map.header.frame_id = map_name + '/map'
      self.map_response[map_name].map.header.stamp = rospy.get_rostime()

      # Publish advertised service
      self.service_server[map_name] = rospy.Service(map_name + '/static_map', 
          GetMap, self.mapCallback)

      # Publish latched topics
      self.metadata_publisher[map_name] = rospy.Publisher(map_name + '/map_metadata',
          MapMetaData, latch=True)
      self.metadata_publisher[map_name].publish(self.map_response[map_name].map.info)
      self.map_publisher[map_name] = rospy.Publisher(map_name + '/map',
          OccupancyGrid, latch=True)
      self.map_publisher[map_name].publish(self.map_response[map_name].map)

    rospy.spin();

  def mapCallback(self, req):
    service = req._connection_header['service']
    for map_name, map_response in self.map_response.items():
      if service == rospy.resolve_name(map_name + '/static_map'):
        return map_response

  def loadMapFromFile(self, image_file, resolution, negate, occupied_thresh,
      free_thresh, origin):

    resp = GetMapResponse()

    image = Image.open(image_file)
    pix = image.load()

    image_size = image.size
    resp.map.info.width = image_size[0]
    resp.map.info.height = image_size[1]
    resp.map.info.resolution = resolution;

    if len(origin) == 3:
      resp.map.info.origin.position.x = origin[0]
      resp.map.info.origin.position.y = origin[1]
      resp.map.info.origin.position.z = 0
      q = quaternion_from_euler(0,0,origin[2])
      resp.map.info.origin.orientation.x = q[0]
      resp.map.info.origin.orientation.y = q[1]
      resp.map.info.origin.orientation.z = q[2]
      resp.map.info.origin.orientation.w = q[3]
    elif len(origin) == 6:
      resp.map.info.origin.position.x = origin[0]
      resp.map.info.origin.position.y = origin[1]
      resp.map.info.origin.position.z = origin[2]
      q = quaternion_from_euler(origin[3], origin[4], origin[5])
      resp.map.info.origin.orientation.x = q[0]
      resp.map.info.origin.orientation.y = q[1]
      resp.map.info.origin.orientation.z = q[2]
      resp.map.info.origin.orientation.w = q[3]
    elif len(origin) == 7:
      resp.map.info.origin.position.x = origin[0]
      resp.map.info.origin.position.y = origin[1]
      resp.map.info.origin.position.z = origin[2]
      resp.map.info.origin.orientation.x = origin[3]
      resp.map.info.origin.orientation.x = origin[4]
      resp.map.info.origin.orientation.x = origin[5]
      resp.map.info.origin.orientation.x = origin[6]
    else:
      raise TypeError("Unable to parse origin tag")

    test_pxl = pix[0,0]
    if isinstance(test_pxl, (list, tuple)):
      is_multi_layer = True
      num_layers = len(test_pxl)
    else:
      is_multi_layer = False
      num_layers = 1

    resp.map.data = [None] * image_size[0] * image_size[1]
    for j in range(image_size[1]):
      for i in range(image_size[0]):

        pxl = pix[i, j]

        if is_multi_layer:
          color_average = sum(pxl) / num_layers
        else:
          color_average = pxl

        if negate:
          occ = color_average / 255.0;
        else:
          occ = (255 - color_average) / 255.0;

        map_idx = resp.map.info.width * (resp.map.info.height - j - 1) + i; 
        if (occ > occupied_thresh):
          resp.map.data[map_idx] = 100
        elif (occ < free_thresh):
          resp.map.data[map_idx] = 0
        else:
          resp.map.data[map_idx] = -1

    return resp

if __name__ == '__main__':
  MapServer()


    

