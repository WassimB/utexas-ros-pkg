#!/usr/bin/env python
import roslib; roslib.load_manifest('bwi_dispatcher')
import rospy
import bwi_dispatcher
import bwi_dispatcher.srv
import bwi_dispatcher.msg
from bwi_dispatcher.msg import MachineStatus

import gateway_comms.msg
import gateway_comms.srv

class Dispatcher():
  def __init__(self):
    self.status = MachineStatus()
    self.status.devices = []
    self.status.applications = []
    self.statuses = {}
    
    statusTopic = rospy.get_param('~status_topic', '/machine')
    self.publishRate = rospy.get_param('~publish_rate', 5)
    self.updateRate = rospy.get_param('~update_rate', 1)
    self.maxDuration = rospy.get_param('~max_status_duration', 2)
    self.status.machine = rospy.get_param('~machine_name', 'machine1')
    self.gateway = rospy.get_param('~gateway', 'gateway')
    self.dservices, self.gservices = self.__setupRosServices()

    self.publisher = rospy.Publisher(statusTopic, MachineStatus)
    self.subscriber = rospy.Subscriber(statusTopic, MachineStatus, lambda x: self.handleStatus(x))

  def __setupRosServices(self):
    dispatcher_services = {}
    dispatcher_services['list_topics'] = rospy.Service('~list_topics', bwi_dispatcher.srv.ListTopics, self.rosServiceListTopics)
    dispatcher_services['advertise'] = rospy.Service('~advertise_device', bwi_dispatcher.srv.AdvertiseNode, self.rosServiceAdvertiseDevice)
    # ... snip ... #

    gateway_services = {}
    gateway_services['advertise'] = rospy.ServiceProxy('/%s/advertise' % self.gateway, gateway_comms.srv.Advertise)
    gateway_services['advertise_all'] = rospy.ServiceProxy('/%s/advertise_all' % self.gateway, gateway_comms.srv.AdvertiseAll)
  
    return dispatcher_services, gateway_services

  def __publishStatus(self):
    self.status.timestamp = rospy.Time.now()
    self.publisher.publish(self.status)
    rospy.loginfo("publishing status for %s" % self.status.machine)

  def handleStatus(self, status):
    self.statuses[status.machine] = status
    rospy.loginfo("handling status")

  def updateStatuses(self):
    for machine in self.statuses.keys():
      s = self.statuses[machine]
      duration = rospy.Time.now() - s.timestamp
      if duration.secs > self.maxDuration:
        del self.statuses[machine]
    rospy.loginfo("updating status")

  def spin(self):
    rospy.Timer(rospy.Duration(self.publishRate), lambda x: self.__publishStatus())
    rospy.Timer(rospy.Duration(self.updateRate), lambda x: self.updateStatuses())
    rospy.spin()    

  ################################################################
  # Ros Service Callbacks
  ###############################################################

  '''
    The idea here is, we list out whatever data we might need,
    pick the topics we want, and then pull them individually before
    subscribing. If we know our topics ahead of time, we can just
    pull them (for debugging)
  '''

  def rosServiceListTopics(self, msg):
    response = bwi_dispatcher.srv.ListTopicsResponse()
    response.topics = []
    #response.topics = [t for t in n.topics for n in self.devices + self.applications]
    for n in self.status.devices + self.status.applications:
      response.topics += n.topics
    return response

  def rosServiceListServices(self, msg):
    response = bwi_dispatcher.srv.ListServicesResponse()
    services = []
    for d in self.status.devices:
      for s in d.services:
        services += [s]
    for a in self.status.applications:
      for s in a.services:
        services += [s]
    response.services = services
    return response

  def rosServiceListDevices(self, msg):
    response = bwi_dispatcher.srv.ListDevicesResponse()
    response.devices = self.status.devices
    return response

  def rosServiceListApplications(self, msg):
    response = bwi_dispatcher.srv.ListApplicationsResponse()
    response.applications = self.status.applications
    return response

  def rosServiceListMachines(self, msg):
    response = bwi_dispatcher.srv.ListMachinesResponse()
    response.machines = self.statuses.keys()
    return response

  def rosServicePullAll(self, pull):
    response = bwi_dispatcher.srv.PullAllResponse()
    request = gateway_comms.srv.RemoteAllRequest()
    request.cancel = pull.cancel
    request.gateway = pull.machine
    self.gservices['pull_all'](request)
    return response

  def rosServicePullTopic(self, pull):
    response = bwi_dispatcher.srv.PullTopicResponse()
    request = gateway_comms.srv.RemoteRequest()
    request.cancel = pull.cancel
    r = gateway_comms.msg.RemoteRule()
    r.gateway = pull.machine
    r.rule.type = pull.type
    r.rule.name = pull.name
    r.rule.node = pull.node
    request.remote = r
    self.gservices['pull'](request)
    return response

  def rosServiceAdvertiseAll(self, msg):
    response = bwi_dispatcher.srv.AdvertiseAllResponse()
    request = gateway_comms.srv.AdvertiseAllRequest()
    request.cancel = msg.cancel
    self.gservices['advertise_all'](request)
    return response

  def rosServiceAdvertiseNode(self, msg):
    response = bwi_dispatcher.srv.AdvertiseNodeResponse()
    request = gateway_comms.srv.AdvertiseRequest()
    request.cancel = msg.cancel
    request.rules = []
    for ad in msg.advertisements:
      r = gateway_comms.msg.Rule()
      r.type = ad.type
      r.name = ad.name
      r.node = msg.node_name
      request.rules += [r]
    r = self.gservices['advertise'](request)
    if r.result == gateway_comms.msg.Result.SUCCESS:
      response.success = True
    else:
      rospy.loginfo("Gateway response: %d" % r.result)
    return response

  def rosServiceAdvertiseApplication(self, msg):
    msg.node_type = bwi_dispatcher.msg.NodeType.APPLICATION
    filter(lambda a: a.name != msg.node_name, self.status.applications)
    response = self.rosServiceAdvertiseNode(msg)
    if not msg.cancel and response.success:
      a = self.getNodeStatus(msg, bwi_dispatcher.msg.Application())
      self.status.applications += [a]
    return response

  def rosServiceAdvertiseDevice(self, msg):
    msg.node_type = bwi_dispatcher.msg.NodeType.DEVICE
    filter(lambda d: d.name != msg.node_name, self.status.devices)
    response = self.rosServiceAdvertiseNode(msg)
    if not msg.cancel and response.success:
      d = self.getNodeStatus(msg, bwi_dispatcher.msg.Device())
      self.status.applications += [d]
    return response

  def getNodeStatus(self, msg, status):
    status.topics = []
    for ad in msg.advertisements:
      if ad.type == bwi_dispatcher.msg.AdvertisementType.PUBLISHER:
        t = bwi_dispatcher.msg.Topic()
        t.name = ad.name
        status.topics += [t]
      if ad.type == bwi_dispatcher.msg.AdvertisementType.SERVICE:
        s = bwi_dispatcher.msg.Service()
        s.name = ad.name
        status.services += [s]
    status.name = msg.node_name
    return status

  def clearRules(self):
    rospy.loginfo("Clearing all rules")
    request = gateway_comms.srv.AdvertiseAllRequest()
    request.cancel = True
    response = self.gservices['advertise_all'](request)
    if response.result != gateway_comms.msg.Result.SUCCESS:
      rospy.loginfo("Gateway response: %d" % r.result)

  def shutdown(self):
    self.clearRules()

if __name__ == '__main__':
  rospy.init_node('dispatcher')
  dispatcher = Dispatcher()
  rospy.on_shutdown(dispatcher.shutdown)
  dispatcher.spin()
  rospy.loginfo('Dispatcher shutting down.')
