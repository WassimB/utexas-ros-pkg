package edu.utexas.ece.pharos.demo.homeAutomation.logAnalyzer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Enumeration;
import java.util.Vector;

import edu.utexas.ece.pharos.utils.Stats;

/**
 * Analyze the log file generated by an experiment involving 
 * asynchronous cyber-physical assertions.
 * 
 * @author Chien-Liang Fok
 */
public class AnalyzeAsyncAssertion2Log {

	Vector<LightReading> lightReadings = new Vector<LightReading>();
	Vector<Round> rounds = new Vector<Round>();
	
	/**
	 * The constructor.
	 * 
	 * @param fileName The name of the log file.
	 */
	public AnalyzeAsyncAssertion2Log() {

		// Read the log files...
		FilenameFilter filter = new FilenameFilter() {
		    public boolean accept(File dir, String name) {
		        return name.startsWith("LightSwitchAppAsync2") && name.contains(".log");
		    }
		};
		
		File dir = new File(".");

		String[] logFiles = dir.list(filter);
		if (logFiles == null) {
		    System.err.println("No files found.");
		    System.exit(1);
		} else {
		    for (int i=0; i<logFiles.length; i++) {
		    	String expFileName = "./" + logFiles[i];
		    	System.out.println("Reading log " + expFileName);
		        rounds.add(readFile(expFileName));
		    }
		}
		
		System.out.println("Number of rounds: " + rounds.size());
//		for (int i=0; i < rounds.size(); i++) {
//			System.out.println(rounds.get(i).toString());
//		}
		
		analyzeTotalExecTime();
		computeAssertionLatency();
		computeAverageDelta();
	}
	
	private void computeAverageDelta() {
		Vector<Double> deltas = new Vector<Double>();
		for (int i=0; i < rounds.size(); i++) {
			Round currRound = rounds.get(i);
			Enumeration<Assertion> e = currRound.assertions.elements();
			while (e.hasMoreElements()) {
				deltas.add((double)e.nextElement().getDelta());
			}
		}
		
		double avg = Stats.getAvg(deltas);
		double conf95 = Stats.getConf95(deltas);
		
		DecimalFormat df = new DecimalFormat("#.##");
		
		System.out.println("Average actual delta: " + df.format(avg) + " +- " + df.format(conf95)
				+ " (sample size = " + deltas.size() + ")");
	}
	
	private void computeAssertionLatency() {
		Vector<Double> latencies = new Vector<Double>();
		
		for (int i=0; i < rounds.size(); i++) {
			Round currRound = rounds.get(i);
			Enumeration<Assertion> e = currRound.assertions.elements();
			while (e.hasMoreElements()) {
				latencies.add((double)e.nextElement().getDuration());
			}
		}
		
		double avg = Stats.getAvg(latencies);
		double conf95 = Stats.getConf95(latencies);
		
		DecimalFormat df = new DecimalFormat("#.##");
		System.out.println("Average assertion latency: " + df.format(avg) + " +- " + df.format(conf95)
				+ " (sample size = " + latencies.size() + ")");
	}
	
	/**
	 * The total execution time is measured from the start of the first assertion
	 * to the end of the last assertion.
	 */
	private void analyzeTotalExecTime() {
		Vector<Double> measurements = new Vector<Double>();
		
		Enumeration<Round> e = rounds.elements();
		while (e.hasMoreElements()) {
			Round currRound = e.nextElement();
			
			measurements.add((double)(currRound.getEndOfLastAssertion() - currRound.getStartOfFirstAssertion()));
		}
		
		double avg = Stats.getAvg(measurements);
		double conf95 = Stats.getConf95(measurements);

		DecimalFormat df = new DecimalFormat("#.##");
		System.out.println("Average execution time = " + df.format(avg) + " +- " + df.format(conf95)
				+ " (sample size = " + measurements.size() + ")");
	}
	
	/**
	 * Reads and organizes the data contained in the log file.
	 * 
	 * @param fileName The log file name.
	 */
	private Round readFile(String fileName) {
		File file = new File(fileName);
		BufferedReader br = null;
		try {
			br = new BufferedReader(new FileReader(file));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			System.exit(1);
		}
		
		String line = null;
		String[] tokens = null;

		int roundNumber = 0;
		if (fileName.contains("-")) {
			tokens = fileName.split("[\\s-.]");
			roundNumber = Integer.valueOf(tokens[2]);
		}
		Round result = new Round(roundNumber);
		Assertion currAssertion = null;
		
		try {
			while ((line = br.readLine()) != null){

				// Save the light measurements
				if (line.contains("Received AmbientLight message")) {
					tokens = line.split("[\\[\\]]");
					long timestamp = Long.valueOf(tokens[1]);
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					tokens = line.split("\\s");
					int seqno = Integer.valueOf(tokens[4]);
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					tokens = line.split("\\s");
					int lightLevel = Integer.valueOf(tokens[4]);
					lightReadings.add(new LightReading(timestamp, seqno, lightLevel));
				}
				else if (line.contains("Asserting")) {
					tokens = line.split("[\\[\\]]");
					long timestamp = Long.valueOf(tokens[1]);
					currAssertion = new Assertion();
					currAssertion.startTime = timestamp;
				}
				else if (line.contains("qualifies!")) {
					tokens = line.split("[\\s\\:.]");
					long secs = Long.valueOf(tokens[7]);
					long nsecs = Long.valueOf(tokens[8]);
					
					// See: http://www.ros.org/doc/api/rosjava_bootstrap/html/classorg_1_1ros_1_1message_1_1Time.html
					long timestamp = (long)((((long) secs) * 1000000000 + nsecs) / 1e6);
					currAssertion.sensorTime = timestamp;
				}
				else if (line.contains("Evaluating")) {
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					tokens = line.split("[\\[\\]\\s]");
					long timestamp = Long.valueOf(tokens[3]);
					currAssertion.endTime = timestamp;
					result.assertions.add(currAssertion);
					currAssertion = null;
				} 
				else if (line.contains("Turning light off")) {
					tokens = line.split("[\\[\\]]");
					long timestamp = Long.valueOf(tokens[1]);
					result.timeOfLightsOffCmd = timestamp;
				}
				else if (line.contains("Light should be off, latency")) {
					tokens = line.split("[\\s]");
					long timestamp = Long.valueOf(tokens[9]);
					result.latencyLightsOffCmd = timestamp;
				}
				else if (line.contains("Turning light on")) {
					tokens = line.split("[\\[\\]]");
					long timestamp = Long.valueOf(tokens[1]);
					result.timeOfLightsOnCmd = timestamp;
				}
				else if (line.contains("Light should be on, latency")) {
					tokens = line.split("[\\s]");
					long timestamp = Long.valueOf(tokens[9]);
					result.latencyLightsOnCmd = timestamp;
				}
			}
		} catch (NumberFormatException e) {
			e.printStackTrace();
			System.exit(1);
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}

		return result;
	}
	
	class Round {
		int roundNumber;
		long timeOfLightsOffCmd, latencyLightsOffCmd,
		timeOfLightsOnCmd, latencyLightsOnCmd;
		
		Vector<Assertion> assertions;
		
		public Round(int roundNumber) {
			this.roundNumber = roundNumber;
			assertions = new Vector<Assertion>();
		}
		
		public long getStartOfFirstAssertion() {
			long result = Long.MAX_VALUE;
			Enumeration<Assertion> e = assertions.elements();
			while (e.hasMoreElements()) {
				Assertion a = e.nextElement();
				if (a.startTime < result)
					result = a.startTime;
			}
			return result;
		}
		
		public long getEndOfLastAssertion() {
			long result = Long.MIN_VALUE;
			Enumeration<Assertion> e = assertions.elements();
			while (e.hasMoreElements()) {
				Assertion a = e.nextElement();
				if (a.endTime > result)
					result = a.endTime;
			}
			return result;
		}
		
		public String toString() {
			StringBuffer sb = new StringBuffer("Round " + roundNumber + ":");
			sb.append("\n\tTime of Lights-Off Command: " + timeOfLightsOffCmd);
			sb.append("\n\tLatency of Lights-Off Command: " + latencyLightsOffCmd);
			sb.append("\n\tTime of Lights-On command: " + timeOfLightsOnCmd);
			sb.append("\n\tLatency of Lights-On command: " + latencyLightsOnCmd);
			sb.append("\n\tNumber of assertions: " + assertions.size());
			for (int i=0; i < assertions.size(); i++) {
				Assertion currAssertion = assertions.get(i);
				sb.append("\n\t\tAssertion " + currAssertion);
			}
			return sb.toString();
		}
	}
	
	class LightReading {
		long timestamp;
		int seqno;
		int value;
		
		public LightReading(long timestamp, int seqno, int value) {
			this.timestamp = timestamp;
			this.seqno = seqno;
			this.value = value;
		}
		
		public String toString() {
			return timestamp + ", " + seqno + ", " + value;
		}
	}
	
	class Assertion {
		long startTime, endTime;
		long sensorTime;
		
		public Assertion() {
		}
		
		public long getDuration() {
			return endTime - startTime;
		}
		
		public long getDelta() {
			return sensorTime - startTime;
		}
		
		public String toString() {
			return "Start Time = " + startTime + ", End Time = " + endTime 
				+ ", Duration = " + getDuration() + ", sensorTime = " + sensorTime 
				+ ", delta = " + getDelta();
		}
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		new AnalyzeAsyncAssertion2Log();
	}
}
