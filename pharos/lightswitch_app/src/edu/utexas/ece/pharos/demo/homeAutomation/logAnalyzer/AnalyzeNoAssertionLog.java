package edu.utexas.ece.pharos.demo.homeAutomation.logAnalyzer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import edu.utexas.ece.pharos.demo.homeAutomation.CPSPredicateRoomBright;
import edu.utexas.ece.pharos.demo.homeAutomation.CPSPredicateRoomDim;
import edu.utexas.ece.pharos.utils.FileLogger;
import edu.utexas.ece.pharos.utils.Stats;

/**
 * Analyze the log file generated by an experiment involving 
 * no cyber-physical assertions.
 * 
 * @author Chien-Liang Fok
 */
public class AnalyzeNoAssertionLog {

	Vector<LightReading> lightReadings = new Vector<LightReading>();
	Vector<Round> rounds = new Vector<Round>();
	
	/**
	 * The constructor.
	 * 
	 * @param fileName The name of the log file.
	 */
	public AnalyzeNoAssertionLog(String fileName) {
		readFile(fileName);
		//printRound2();
		//analyzeLoff();
		//analyzeLon();
		//analyzeCmdExecLatency();
		analyzeTotalExecTime();
	}
	
	private void analyzeTotalExecTime() {
		Vector<Double> measurements = new Vector<Double>();
		
		Enumeration<Round> e = rounds.elements();
		while (e.hasMoreElements()) {
			Round currRound = e.nextElement();
			
			measurements.add((double)(currRound.timeOfLightsOnCmd - currRound.timeOfLightsOffCmd));
		}
		
		double avg = Stats.getAvg(measurements);
		double conf95 = Stats.getConf95(measurements);
		
		System.out.println("Num Measurements: " + measurements.size());
		System.out.println("Execution time = " + avg + " +- " + conf95);
	}
	
	private void analyzeCmdExecLatency() {
		Vector<Double> measurements = new Vector<Double>();
		
		Enumeration<Round> e = rounds.elements();
		while (e.hasMoreElements()) {
			Round currRound = e.nextElement();
			
			// divide by 1000 to convert to micro-seconds
			measurements.add(currRound.latencyLightsOffCmd / 1000.0);
			measurements.add(currRound.latencyLightsOnCmd / 1000.0);
		}
		
		double avg = Stats.getAvg(measurements);
		double conf95 = Stats.getConf95(measurements);
		
		System.out.println("Num Measurements: " + measurements.size());
		System.out.println("Cmd latency = " + avg + " +- " + conf95);
	}
	
	private void analyzeLon() {
		
		Vector<Double> measurements = new Vector<Double>();
		
		Enumeration<Round> e = rounds.elements();
		while (e.hasMoreElements()) {
			Round currRound = e.nextElement();
			
			long lightsOnTime = currRound.timeOfLightsOnCmd;
			LightReading transitionReading = null;
			
			// Search for the first light measurement after the lights off time that is low
			for (int i=0; i < lightReadings.size() && transitionReading == null; i++) {
				LightReading currReading = lightReadings.get(i);
				if (currReading.timestamp > lightsOnTime && currReading.value > CPSPredicateRoomBright.BRIGHT_THRESHOLD) {
					transitionReading = currReading;
				}
			}
			
			if (transitionReading != null) {
				long deltaTime = transitionReading.timestamp - lightsOnTime;
				measurements.add((double)deltaTime);
			} else {
				System.err.println("Unable to find transition reading!");
				System.exit(1);
			}
		}
		
		double avg = Stats.getAvg(measurements);
		double conf95 = Stats.getConf95(measurements);
		
		System.out.println("Num Rounds: " + measurements.size());
		System.out.println("L_on = " + avg + " +- " + conf95);
		
	}
	
	private void analyzeLoff() {
		
		Vector<Double> measurements = new Vector<Double>();
		
		Enumeration<Round> e = rounds.elements();
		while (e.hasMoreElements()) {
			Round currRound = e.nextElement();
			
			long lightsOffTime = currRound.timeOfLightsOffCmd;
			LightReading transitionReading = null;
			
			// Search for the first light measurement after the lights off time that is low
			for (int i=0; i < lightReadings.size() && transitionReading == null; i++) {
				LightReading currReading = lightReadings.get(i);
				if (currReading.timestamp > lightsOffTime && currReading.value < CPSPredicateRoomDim.DIM_THRESHOLD) {
					transitionReading = currReading;
				}
			}
			
			if (transitionReading != null) {
				long deltaTime = transitionReading.timestamp - lightsOffTime;
				measurements.add((double)deltaTime);
			} else {
				System.err.println("Unable to find transition reading!");
				System.exit(1);
			}
		}
		
		double avg = Stats.getAvg(measurements);
		double conf95 = Stats.getConf95(measurements);
		
		System.out.println("Num Rounds: " + measurements.size());
		System.out.println("L_off = " + avg + " +- " + conf95);
		
	}
	
	private void printRound2() {
		Round round1 = rounds.get(1);
		long timeOfLightsOffCmd = round1.timeOfLightsOffCmd;
		long timeOfLightsOnCmd = round1.timeOfLightsOnCmd;
		
		// Gather sensor readings one second before and after the
		// experiment.
		long startTime = timeOfLightsOffCmd - 1000;
		long endTime = timeOfLightsOnCmd + 1000;
		
		Vector<LightReading> relevantReadings = new Vector<LightReading>();
		
		Enumeration<LightReading> e = lightReadings.elements();
		while (e.hasMoreElements()) {
			LightReading currReading = e.nextElement();
			if (currReading.timestamp > startTime && currReading.timestamp < endTime)
				relevantReadings.add(currReading);
		}
		
		FileLogger flogger = new FileLogger("Round2.txt", false);
		flogger.log("Time of lights off command = " + (timeOfLightsOffCmd - startTime));
		flogger.log("Time of lights on command = " + (timeOfLightsOnCmd - startTime));
		
		flogger.log("Timestamp (ms), Timestamp (s), Sequence Number, Light Reading");
		e = relevantReadings.elements();
		while (e.hasMoreElements()) {
			LightReading currReading = e.nextElement();
			long timestamp = currReading.timestamp - startTime;
			flogger.log(timestamp + ", " + (timestamp / 1000.0) + ", " + currReading.seqno + ", " + currReading.value);
		}
		
	}
	
	/**
	 * Reads and organizes the data contained in the log file.
	 * 
	 * @param fileName The log file name.
	 */
	private void readFile(String fileName) {
		File file = new File(fileName);
		BufferedReader br = null;
		try {
			br = new BufferedReader(new FileReader(file));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			System.exit(1);
		}
		String line = null;

		try {
			while ((line = br.readLine()) != null){

				// Save the light measurements
				if (line.contains("Received AmbientLight message")) {
					String[] tokens = line.split("[\\[\\]]");
					long timestamp = Long.valueOf(tokens[1]);
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					tokens = line.split("\\s");
					int seqno = Integer.valueOf(tokens[4]);
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					line = br.readLine();
					tokens = line.split("\\s");
					int lightLevel = Integer.valueOf(tokens[4]);
					lightReadings.add(new LightReading(timestamp, seqno, lightLevel));
				}
				else if (line.contains("Round")) {
					String[] tokens = line.split("[\\s]");
					int roundNumber = Integer.valueOf(tokens[4]);
					
					line = br.readLine();
					tokens = line.split("[\\[\\]]");
					long timeOfLightsOffCmd = Long.valueOf(tokens[1]);
					
					line = br.readLine();
					tokens = line.split("[\\s]");
					long latencyLightsOffCmd = Long.valueOf(tokens[8]);
					
					line = br.readLine();
					
					line = br.readLine();
					tokens = line.split("[\\[\\]]");
					long timeOfLightsOnCmd = Long.valueOf(tokens[1]);
					
					line = br.readLine();
					tokens = line.split("[\\s]");
					long latencyLightsOnCmd = Long.valueOf(tokens[8]);
					
					Round round = new Round(roundNumber, timeOfLightsOffCmd, 
							latencyLightsOffCmd, timeOfLightsOnCmd, latencyLightsOnCmd);
					rounds.add(round);
				}
			}
		} catch (NumberFormatException e) {
			e.printStackTrace();
			System.exit(1);
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}

		// debugging code to verify that the light readings were successfully read in.
//		Enumeration<LightReading> e = lightReadings.elements();
//		while (e.hasMoreElements()) {
//			System.out.println(e.nextElement().toString());
//		}
		
		// debugging code to verify that the round information was successfully read in.
//		Enumeration<Round> e2 = rounds.elements();
//		while (e2.hasMoreElements()) {
//			System.out.println(e2.nextElement().toString());
//		}
	}
	
	class Round {
		int roundNumber;
		long timeOfLightsOffCmd, latencyLightsOffCmd,
		timeOfLightsOnCmd, latencyLightsOnCmd;
		
		public Round(int roundNumber, long timeOfLightsOffCmd, long latencyLightsOffCmd,
				long timeOfLightsOnCmd, long latencyLightsOnCmd) 
		{
			this.roundNumber = roundNumber;
			this.timeOfLightsOffCmd = timeOfLightsOffCmd;
			this.latencyLightsOffCmd = latencyLightsOffCmd;
			this.timeOfLightsOnCmd = timeOfLightsOnCmd;
			this.latencyLightsOnCmd = latencyLightsOnCmd;
		}
		
		public String toString() {
			return roundNumber + ", " + timeOfLightsOffCmd + ", " + latencyLightsOffCmd 
				+ ", " + timeOfLightsOnCmd + ", " + latencyLightsOnCmd;
		}
	}
	
	class LightReading {
		long timestamp;
		int seqno;
		int value;
		
		public LightReading(long timestamp, int seqno, int value) {
			this.timestamp = timestamp;
			this.seqno = seqno;
			this.value = value;
		}
		
		public String toString() {
			return timestamp + ", " + seqno + ", " + value;
		}
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		if (args.length != 1) {
			System.out.println("Usage: AnalyzeNoAssertionLog [log file name]");
			System.exit(0);
		} else {
			new AnalyzeNoAssertionLog(args[0]);
		}
	}

}
